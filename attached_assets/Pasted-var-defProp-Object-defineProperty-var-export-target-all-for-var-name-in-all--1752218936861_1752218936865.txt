var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// server/index.ts
import express2 from "express";

// server/routes.ts
import { createServer } from "http";

// shared/schema.ts
var schema_exports = {};
__export(schema_exports, {
  achievements: () => achievements,
  esgMetrics: () => esgMetrics,
  insertAchievementSchema: () => insertAchievementSchema,
  insertEsgMetricsSchema: () => insertEsgMetricsSchema,
  insertMarketInsightSchema: () => insertMarketInsightSchema,
  insertPredictionSchema: () => insertPredictionSchema,
  insertProjectSchema: () => insertProjectSchema,
  insertProjectTypeEsgTemplateSchema: () => insertProjectTypeEsgTemplateSchema,
  insertRewardActivitySchema: () => insertRewardActivitySchema,
  insertRewardChallengeSchema: () => insertRewardChallengeSchema,
  insertUserAchievementSchema: () => insertUserAchievementSchema,
  insertUserChallengeProgressSchema: () => insertUserChallengeProgressSchema,
  marketInsights: () => marketInsights,
  predictions: () => predictions,
  projectTypeEsgTemplates: () => projectTypeEsgTemplates,
  projects: () => projects,
  rewardActivities: () => rewardActivities,
  rewardChallenges: () => rewardChallenges,
  sessions: () => sessions,
  userAchievements: () => userAchievements,
  userChallengeProgress: () => userChallengeProgress,
  users: () => users
});
import { pgTable, text, serial, integer, boolean, real, timestamp, varchar, jsonb, index } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
var projects = pgTable("projects", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  type: text("type").notNull(),
  // solar, wind, hydro, biomass, geothermal
  location: text("location").notNull(),
  capacity: real("capacity").notNull(),
  // MW
  status: text("status").notNull(),
  // active, pending, completed
  irr: real("irr").notNull(),
  esgScore: real("esg_score").notNull(),
  riskLevel: text("risk_level").notNull(),
  // low, medium, high
  createdAt: timestamp("created_at").defaultNow().notNull()
});
var predictions = pgTable("predictions", {
  id: serial("id").primaryKey(),
  projectType: text("project_type").notNull(),
  location: text("location").notNull(),
  gridStability: text("grid_stability").notNull(),
  communityEngagement: text("community_engagement").notNull(),
  projectSize: real("project_size").notNull(),
  predictedIrr: real("predicted_irr").notNull(),
  successProbability: real("success_probability").notNull(),
  riskLevel: text("risk_level").notNull(),
  confidence: real("confidence").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull()
});
var esgMetrics = pgTable("esg_metrics", {
  id: serial("id").primaryKey(),
  projectId: integer("project_id").references(() => projects.id),
  environmental: real("environmental").notNull(),
  social: real("social").notNull(),
  governance: real("governance").notNull(),
  overall: real("overall").notNull(),
  co2Reduction: real("co2_reduction").notNull(),
  // tons/year
  cleanEnergyGenerated: real("clean_energy_generated").notNull(),
  // GWh
  waterSaved: real("water_saved").notNull(),
  // liters
  jobsCreated: integer("jobs_created").notNull(),
  communitiesServed: integer("communities_served").notNull(),
  educationPrograms: integer("education_programs").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull()
});
var marketInsights = pgTable("market_insights", {
  id: serial("id").primaryKey(),
  title: text("title").notNull(),
  date: timestamp("date").notNull(),
  excerpt: text("excerpt").notNull(),
  content: text("content"),
  author: text("author"),
  createdAt: timestamp("created_at").defaultNow().notNull()
});
var projectTypeEsgTemplates = pgTable("project_type_esg_templates", {
  id: serial("id").primaryKey(),
  projectType: text("project_type").notNull(),
  // solar, wind, hydro, biomass, geothermal
  environmental: real("environmental").notNull(),
  social: real("social").notNull(),
  governance: real("governance").notNull(),
  overall: real("overall").notNull(),
  co2Reduction: real("co2_reduction").notNull(),
  cleanEnergyGenerated: real("clean_energy_generated").notNull(),
  waterSaved: real("water_saved").notNull(),
  jobsCreated: integer("jobs_created").notNull(),
  communitiesServed: integer("communities_served").notNull(),
  educationPrograms: integer("education_programs").notNull(),
  riskCategory: text("risk_category").notNull(),
  // low, medium, high
  createdAt: timestamp("created_at").defaultNow().notNull()
});
var sessions = pgTable(
  "sessions",
  {
    sid: varchar("sid").primaryKey(),
    sess: jsonb("sess").notNull(),
    expire: timestamp("expire").notNull()
  },
  (table) => [index("IDX_session_expire").on(table.expire)]
);
var users = pgTable("users", {
  id: varchar("id").primaryKey().notNull(),
  email: varchar("email").unique().notNull(),
  passwordHash: varchar("password_hash"),
  firstName: varchar("first_name"),
  lastName: varchar("last_name"),
  profileImageUrl: varchar("profile_image_url"),
  stripeCustomerId: varchar("stripe_customer_id"),
  stripeSubscriptionId: varchar("stripe_subscription_id"),
  subscriptionStatus: varchar("subscription_status").default("inactive"),
  // active, inactive, past_due, canceled
  subscriptionPlan: varchar("subscription_plan").default("free"),
  // free, basic, premium
  subscriptionStartDate: timestamp("subscription_start_date"),
  subscriptionEndDate: timestamp("subscription_end_date"),
  // Micro-Reward System fields
  sustainabilityPoints: integer("sustainability_points").default(0),
  level: integer("level").default(1),
  xp: integer("xp").default(0),
  streak: integer("streak").default(0),
  lastActivityDate: timestamp("last_activity_date"),
  totalCo2Saved: real("total_co2_saved").default(0),
  totalEnergyGenerated: real("total_energy_generated").default(0),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow()
});
var achievements = pgTable("achievements", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  description: text("description").notNull(),
  icon: text("icon").notNull(),
  category: text("category").notNull(),
  // environmental, social, governance, financial
  difficulty: text("difficulty").notNull(),
  // bronze, silver, gold, platinum
  points: integer("points").notNull(),
  requirement: jsonb("requirement").notNull(),
  // {type: "co2_saved", value: 1000}
  isActive: boolean("is_active").default(true),
  createdAt: timestamp("created_at").defaultNow()
});
var userAchievements = pgTable("user_achievements", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id).notNull(),
  achievementId: integer("achievement_id").references(() => achievements.id).notNull(),
  unlockedAt: timestamp("unlocked_at").defaultNow(),
  progress: real("progress").default(0)
  // 0.0 to 1.0
});
var rewardActivities = pgTable("reward_activities", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id).notNull(),
  activityType: text("activity_type").notNull(),
  // project_created, prediction_made, esg_improved, daily_login
  description: text("description").notNull(),
  points: integer("points").notNull(),
  xpGained: integer("xp_gained").notNull(),
  metadata: jsonb("metadata"),
  // Additional activity data
  createdAt: timestamp("created_at").defaultNow()
});
var rewardChallenges = pgTable("reward_challenges", {
  id: serial("id").primaryKey(),
  title: text("title").notNull(),
  description: text("description").notNull(),
  type: text("type").notNull(),
  // daily, weekly, monthly, special
  requirement: jsonb("requirement").notNull(),
  // {type: "projects_created", value: 5}
  reward: jsonb("reward").notNull(),
  // {points: 100, xp: 50, badge: "eco_warrior"}
  isActive: boolean("is_active").default(true),
  startDate: timestamp("start_date"),
  endDate: timestamp("end_date"),
  createdAt: timestamp("created_at").defaultNow()
});
var userChallengeProgress = pgTable("user_challenge_progress", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id).notNull(),
  challengeId: integer("challenge_id").references(() => rewardChallenges.id).notNull(),
  progress: real("progress").default(0),
  // 0.0 to 1.0
  completed: boolean("completed").default(false),
  completedAt: timestamp("completed_at"),
  rewardClaimed: boolean("reward_claimed").default(false),
  createdAt: timestamp("created_at").defaultNow()
});
var insertProjectSchema = createInsertSchema(projects).omit({
  id: true,
  createdAt: true
});
var insertPredictionSchema = createInsertSchema(predictions).omit({
  id: true,
  predictedIrr: true,
  successProbability: true,
  riskLevel: true,
  confidence: true,
  createdAt: true
});
var insertEsgMetricsSchema = createInsertSchema(esgMetrics).omit({
  id: true,
  createdAt: true
});
var insertMarketInsightSchema = createInsertSchema(marketInsights).omit({
  id: true,
  createdAt: true
});
var insertProjectTypeEsgTemplateSchema = createInsertSchema(projectTypeEsgTemplates).omit({
  id: true,
  createdAt: true
});
var insertAchievementSchema = createInsertSchema(achievements).omit({
  id: true,
  createdAt: true
});
var insertUserAchievementSchema = createInsertSchema(userAchievements).omit({
  id: true,
  unlockedAt: true
});
var insertRewardActivitySchema = createInsertSchema(rewardActivities).omit({
  id: true,
  createdAt: true
});
var insertRewardChallengeSchema = createInsertSchema(rewardChallenges).omit({
  id: true,
  createdAt: true
});
var insertUserChallengeProgressSchema = createInsertSchema(userChallengeProgress).omit({
  id: true,
  createdAt: true
});

// server/db.ts
import { Pool, neonConfig } from "@neondatabase/serverless";
import { drizzle } from "drizzle-orm/neon-serverless";
import ws from "ws";
neonConfig.webSocketConstructor = ws;
if (!process.env.DATABASE_URL) {
  throw new Error(
    "DATABASE_URL must be set. Did you forget to provision a database?"
  );
}
var pool = new Pool({ connectionString: process.env.DATABASE_URL });
var db = drizzle({ client: pool, schema: schema_exports });

// server/storage.ts
import { eq } from "drizzle-orm";
var DatabaseStorage = class {
  // User operations
  async getUser(id) {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user;
  }
  async getUserByEmail(email) {
    const [user] = await db.select().from(users).where(eq(users.email, email));
    return user;
  }
  async createUser(userData) {
    const id = `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const [user] = await db.insert(users).values({
      id,
      email: userData.email,
      passwordHash: userData.passwordHash,
      firstName: userData.firstName,
      lastName: userData.lastName
    }).returning();
    return user;
  }
  async upsertUser(userData) {
    const [user] = await db.insert(users).values(userData).onConflictDoUpdate({
      target: users.id,
      set: {
        ...userData,
        updatedAt: /* @__PURE__ */ new Date()
      }
    }).returning();
    return user;
  }
  async updateUserSubscription(userId, subscriptionData) {
    const [user] = await db.update(users).set({
      ...subscriptionData,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq(users.id, userId)).returning();
    return user;
  }
  async seedData() {
    const existingProjects = await db.select().from(projects);
    if (existingProjects.length > 0) {
      return;
    }
    const [project1] = await db.insert(projects).values({
      name: "Lagos Solar Farm",
      type: "solar",
      location: "lagos",
      capacity: 5,
      status: "active",
      irr: 16.8,
      esgScore: 8.9,
      riskLevel: "low"
    }).returning();
    const [project2] = await db.insert(projects).values({
      name: "Abuja Wind Project",
      type: "wind",
      location: "abuja",
      capacity: 2.5,
      status: "pending",
      irr: 14.5,
      esgScore: 8.2,
      riskLevel: "medium"
    }).returning();
    await db.insert(esgMetrics).values({
      projectId: project1.id,
      environmental: 8.7,
      social: 8.1,
      governance: 8.4,
      overall: 8.4,
      co2Reduction: 2450,
      cleanEnergyGenerated: 12.5,
      waterSaved: 89e4,
      jobsCreated: 156,
      communitiesServed: 8,
      educationPrograms: 4
    });
    await db.insert(marketInsights).values([
      {
        title: "The AI Revolution in Renewable Energy Investment",
        date: /* @__PURE__ */ new Date("2024-12-15"),
        excerpt: "Discover how artificial intelligence is transforming renewable energy investment decisions and why traditional models are failing.",
        content: null,
        author: "FinergyCloud Research Team"
      },
      {
        title: "ESG Scoring Revolution: Making Sustainability Measurable",
        date: /* @__PURE__ */ new Date("2024-12-12"),
        excerpt: "How AI is revolutionizing ESG scoring and making environmental impact quantifiable.",
        content: null,
        author: "FinergyCloud Research Team"
      }
    ]);
    await this.seedRewardData();
  }
  async seedRewardData() {
    const existingAchievements = await db.select().from(achievements).limit(1);
    if (existingAchievements.length > 0) {
      return;
    }
    await db.insert(achievements).values([
      {
        title: "First Investment",
        description: "Make your first renewable energy investment",
        icon: "trophy",
        category: "investment",
        difficulty: "easy",
        points: 100,
        requirement: { type: "sustainability_points", value: 50 },
        isActive: true
      },
      {
        title: "Green Champion",
        description: "Save 1000 tons of CO2 through investments",
        icon: "leaf",
        category: "environmental",
        difficulty: "medium",
        points: 250,
        requirement: { type: "co2_saved", value: 1e3 },
        isActive: true
      },
      {
        title: "Energy Pioneer",
        description: "Generate 10 MWh of clean energy",
        icon: "zap",
        category: "environmental",
        difficulty: "medium",
        points: 200,
        requirement: { type: "energy_generated", value: 10 },
        isActive: true
      },
      {
        title: "Sustainability Streak",
        description: "Maintain a 30-day activity streak",
        icon: "calendar",
        category: "engagement",
        difficulty: "hard",
        points: 500,
        requirement: { type: "streak", value: 30 },
        isActive: true
      },
      {
        title: "Level Master",
        description: "Reach level 10 in the platform",
        icon: "star",
        category: "engagement",
        difficulty: "hard",
        points: 1e3,
        requirement: { type: "level", value: 10 },
        isActive: true
      }
    ]);
    await db.insert(rewardChallenges).values([
      {
        title: "Weekly Green Investor",
        description: "Make 3 sustainable investments this week",
        category: "investment",
        difficulty: "medium",
        points: 150,
        xpReward: 300,
        requirement: { type: "investments", value: 3 },
        isActive: true,
        startDate: /* @__PURE__ */ new Date(),
        endDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1e3)
        // 7 days from now
      },
      {
        title: "ESG Analysis Expert",
        description: "Complete ESG analysis for 5 projects",
        category: "analysis",
        difficulty: "medium",
        points: 100,
        xpReward: 200,
        requirement: { type: "esg_analyses", value: 5 },
        isActive: true,
        startDate: /* @__PURE__ */ new Date(),
        endDate: new Date(Date.now() + 14 * 24 * 60 * 60 * 1e3)
        // 14 days from now
      },
      {
        title: "Daily Engagement",
        description: "Use the platform for 7 consecutive days",
        category: "engagement",
        difficulty: "easy",
        points: 75,
        xpReward: 150,
        requirement: { type: "daily_logins", value: 7 },
        isActive: true,
        startDate: /* @__PURE__ */ new Date(),
        endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1e3)
        // 30 days from now
      }
    ]);
  }
  async getProjects() {
    return await db.select().from(projects);
  }
  async getProject(id) {
    const [project] = await db.select().from(projects).where(eq(projects.id, id));
    return project || void 0;
  }
  async createProject(insertProject) {
    const [project] = await db.insert(projects).values(insertProject).returning();
    return project;
  }
  async getPredictions() {
    return await db.select().from(predictions);
  }
  async createPrediction(insertPrediction) {
    const { projectType, location, gridStability, communityEngagement, projectSize } = insertPrediction;
    let baseIrr = 12;
    let successProb = 0.75;
    let confidence = 0.85;
    switch (projectType) {
      case "solar":
        baseIrr += 2.5;
        successProb += 0.1;
        break;
      case "wind":
        baseIrr += 1.8;
        successProb += 0.08;
        break;
      case "hydro":
        baseIrr += 3;
        successProb += 0.12;
        break;
    }
    if (location === "lagos" || location === "abuja") {
      baseIrr += 1;
      successProb += 0.05;
    }
    switch (gridStability) {
      case "high":
        baseIrr += 0.8;
        successProb += 0.08;
        break;
      case "medium":
        baseIrr += 0.3;
        break;
      case "low":
        baseIrr -= 0.5;
        successProb -= 0.1;
        break;
    }
    if (projectSize > 5) {
      baseIrr += 0.5;
      confidence += 0.05;
    }
    const predictedIrr = Math.max(8, Math.min(25, baseIrr + (Math.random() - 0.5) * 2));
    const finalSuccessProb = Math.max(0.5, Math.min(0.95, successProb + (Math.random() - 0.5) * 0.1));
    const finalConfidence = Math.max(0.75, Math.min(0.98, confidence + (Math.random() - 0.5) * 0.1));
    let riskLevel = "medium";
    if (predictedIrr > 15 && finalSuccessProb > 0.85) riskLevel = "low";
    if (predictedIrr < 12 || finalSuccessProb < 0.7) riskLevel = "high";
    const predictionData = {
      ...insertPrediction,
      predictedIrr: Math.round(predictedIrr * 10) / 10,
      successProbability: Math.round(finalSuccessProb * 100) / 100,
      riskLevel,
      confidence: Math.round(finalConfidence * 100) / 100
    };
    const [prediction] = await db.insert(predictions).values(predictionData).returning();
    return prediction;
  }
  async getEsgMetrics() {
    return await db.select().from(esgMetrics);
  }
  async getEsgMetricsByProjectId(projectId) {
    const [metrics] = await db.select().from(esgMetrics).where(eq(esgMetrics.projectId, projectId));
    return metrics || void 0;
  }
  async createEsgMetrics(insertMetrics) {
    const [metrics] = await db.insert(esgMetrics).values(insertMetrics).returning();
    return metrics;
  }
  async getMarketInsights() {
    return await db.select().from(marketInsights);
  }
  async createMarketInsight(insertInsight) {
    const [insight] = await db.insert(marketInsights).values(insertInsight).returning();
    return insight;
  }
  async getProjectTypeEsgTemplates() {
    return await db.select().from(projectTypeEsgTemplates);
  }
  async getProjectTypeEsgTemplate(projectType) {
    const [template] = await db.select().from(projectTypeEsgTemplates).where(eq(projectTypeEsgTemplates.projectType, projectType));
    return template || void 0;
  }
  async createProjectTypeEsgTemplate(insertTemplate) {
    const [template] = await db.insert(projectTypeEsgTemplates).values(insertTemplate).returning();
    return template;
  }
  // Micro-Reward System implementation
  async getUserRewardStats(userId) {
    const [user] = await db.select().from(users).where(eq(users.id, userId));
    if (!user) {
      throw new Error("User not found");
    }
    return {
      sustainabilityPoints: user.sustainabilityPoints || 0,
      level: user.level || 1,
      xp: user.xp || 0,
      streak: user.streak || 0,
      totalCo2Saved: user.totalCo2Saved || 0,
      totalEnergyGenerated: user.totalEnergyGenerated || 0
    };
  }
  async getUserAchievements(userId) {
    const userAchievs = await db.select().from(userAchievements).where(eq(userAchievements.userId, userId));
    return userAchievs;
  }
  async getAchievements() {
    const achievs = await db.select().from(achievements).where(eq(achievements.isActive, true));
    return achievs;
  }
  async getUserRewardActivities(userId) {
    const activities = await db.select().from(rewardActivities).where(eq(rewardActivities.userId, userId)).orderBy(rewardActivities.createdAt);
    return activities;
  }
  async getActiveChallenges() {
    const challenges = await db.select().from(rewardChallenges).where(eq(rewardChallenges.isActive, true));
    return challenges;
  }
  async getUserChallengeProgress(userId) {
    const progress = await db.select().from(userChallengeProgress).where(eq(userChallengeProgress.userId, userId));
    return progress;
  }
  async addRewardActivity(activity) {
    const [newActivity] = await db.insert(rewardActivities).values(activity).returning();
    return newActivity;
  }
  async updateUserRewardStats(userId, stats) {
    const [updatedUser] = await db.update(users).set({
      ...stats,
      lastActivityDate: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq(users.id, userId)).returning();
    return updatedUser;
  }
  async checkAndUnlockAchievements(userId) {
    const userStats = await this.getUserRewardStats(userId);
    const allAchievements = await this.getAchievements();
    const userAchievements2 = await this.getUserAchievements(userId);
    const unlockedAchievements = [];
    const userAchievementIds = new Set(userAchievements2.map((ua) => ua.achievementId));
    for (const achievement of allAchievements) {
      if (userAchievementIds.has(achievement.id)) continue;
      const requirement = achievement.requirement;
      let isUnlocked = false;
      switch (requirement.type) {
        case "sustainability_points":
          isUnlocked = userStats.sustainabilityPoints >= requirement.value;
          break;
        case "co2_saved":
          isUnlocked = userStats.totalCo2Saved >= requirement.value;
          break;
        case "energy_generated":
          isUnlocked = userStats.totalEnergyGenerated >= requirement.value;
          break;
        case "level":
          isUnlocked = userStats.level >= requirement.value;
          break;
        case "streak":
          isUnlocked = userStats.streak >= requirement.value;
          break;
      }
      if (isUnlocked) {
        await db.insert(userAchievements2).values({
          userId,
          achievementId: achievement.id,
          progress: 1
        });
        unlockedAchievements.push(achievement);
      }
    }
    return unlockedAchievements;
  }
  async updateChallengeProgress(userId, challengeId, progress) {
    const [existingProgress] = await db.select().from(userChallengeProgress).where(eq(userChallengeProgress.userId, userId)).where(eq(userChallengeProgress.challengeId, challengeId));
    if (existingProgress) {
      const [updated] = await db.update(userChallengeProgress).set({
        progress,
        completed: progress >= 1,
        completedAt: progress >= 1 ? /* @__PURE__ */ new Date() : null
      }).where(eq(userChallengeProgress.id, existingProgress.id)).returning();
      return updated;
    } else {
      const [newProgress] = await db.insert(userChallengeProgress).values({
        userId,
        challengeId,
        progress,
        completed: progress >= 1,
        completedAt: progress >= 1 ? /* @__PURE__ */ new Date() : null
      }).returning();
      return newProgress;
    }
  }
};
var storage = new DatabaseStorage();
storage.seedData().catch(console.error);

// server/auth.ts
import session from "express-session";
import connectPg from "connect-pg-simple";
function getSession() {
  const sessionTtl = 7 * 24 * 60 * 60 * 1e3;
  const pgStore = connectPg(session);
  const sessionStore = new pgStore({
    conString: process.env.DATABASE_URL,
    createTableIfMissing: false,
    ttl: sessionTtl,
    tableName: "sessions"
  });
  return session({
    secret: process.env.SESSION_SECRET || "your-secret-key-here",
    store: sessionStore,
    resave: false,
    saveUninitialized: false,
    cookie: {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      maxAge: sessionTtl
    }
  });
}
async function setupAuth(app2) {
  app2.set("trust proxy", 1);
  app2.use(getSession());
  app2.post("/api/auth/login", async (req, res) => {
    try {
      const { email, password } = req.body;
      if (!email || !password) {
        return res.status(400).json({ message: "Email and password are required" });
      }
      const demoUser = {
        id: "17743017",
        email,
        firstName: "Joshua",
        lastName: "Nwani",
        profileImageUrl: null,
        stripeCustomerId: null,
        stripeSubscriptionId: null,
        subscriptionStatus: "active",
        subscriptionPlan: "basic",
        subscriptionStartDate: /* @__PURE__ */ new Date(),
        subscriptionEndDate: null,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      };
      req.session.user = demoUser;
      res.json({ user: demoUser, message: "Login successful" });
    } catch (error) {
      console.error("Login error:", error);
      res.status(500).json({ message: "Login failed" });
    }
  });
  app2.post("/api/auth/register", async (req, res) => {
    try {
      const { email, firstName, lastName } = req.body;
      if (!email) {
        return res.status(400).json({ message: "Email is required" });
      }
      const demoUser = {
        id: "17743017",
        email,
        firstName: firstName || "Joshua",
        lastName: lastName || "Nwani",
        profileImageUrl: null,
        stripeCustomerId: null,
        stripeSubscriptionId: null,
        subscriptionStatus: "active",
        subscriptionPlan: "free",
        subscriptionStartDate: /* @__PURE__ */ new Date(),
        subscriptionEndDate: null,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      };
      req.session.user = demoUser;
      res.json({ user: demoUser, message: "Registration successful" });
    } catch (error) {
      console.error("Registration error:", error);
      res.status(500).json({ message: "Registration failed" });
    }
  });
  app2.post("/api/auth/logout", (req, res) => {
    req.session.destroy((err) => {
      if (err) {
        return res.status(500).json({ message: "Logout failed" });
      }
      res.json({ message: "Logout successful" });
    });
  });
  app2.get("/api/login", (req, res) => {
    res.redirect("/login");
  });
}
var isAuthenticated = (req, res, next) => {
  if (req.session?.user) {
    req.user = req.session.user;
    return next();
  }
  res.status(401).json({ message: "Unauthorized" });
};

// server/routes.ts
import { z } from "zod";
async function registerRoutes(app2) {
  await setupAuth(app2);
  app2.get("/api/health", (req, res) => {
    res.json({ status: "ok", timestamp: (/* @__PURE__ */ new Date()).toISOString() });
  });
  app2.get("/api/auth/user", async (req, res) => {
    try {
      if (req.session?.user) {
        return res.json(req.session.user);
      }
      const demoUser = {
        id: "17743017",
        email: "demo@finergycloud.com",
        firstName: "Joshua",
        lastName: "Nwani",
        profileImageUrl: null,
        stripeCustomerId: null,
        stripeSubscriptionId: null,
        subscriptionStatus: "active",
        subscriptionPlan: "basic",
        subscriptionStartDate: /* @__PURE__ */ new Date(),
        subscriptionEndDate: null,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      };
      req.session.user = demoUser;
      res.json(demoUser);
    } catch (error) {
      console.error("Error fetching user:", error);
      res.status(500).json({ message: "Failed to fetch user" });
    }
  });
  app2.get("/api/subscription/status", isAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      res.json({
        plan: user.subscriptionPlan || "free",
        status: user.subscriptionStatus || "inactive",
        startDate: user.subscriptionStartDate,
        endDate: user.subscriptionEndDate,
        stripeCustomerId: user.stripeCustomerId,
        stripeSubscriptionId: user.stripeSubscriptionId
      });
    } catch (error) {
      console.error("Error fetching subscription status:", error);
      res.status(500).json({ message: "Failed to fetch subscription status" });
    }
  });
  app2.post("/api/subscription/create", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const { planId, successUrl, cancelUrl } = req.body;
      const validPlans = ["free", "basic", "premium"];
      if (!validPlans.includes(planId)) {
        return res.status(400).json({ message: "Invalid plan ID" });
      }
      if (planId === "free") {
        await storage.updateUserSubscription(userId, {
          subscriptionPlan: "free",
          subscriptionStatus: "active",
          subscriptionStartDate: /* @__PURE__ */ new Date()
        });
        return res.json({
          success: true,
          message: "Successfully switched to free plan"
        });
      }
      const mockStripeCustomerId = `cus_mock_${userId}_${Date.now()}`;
      const mockStripeSubscriptionId = `sub_mock_${userId}_${Date.now()}`;
      await storage.updateUserSubscription(userId, {
        stripeCustomerId: mockStripeCustomerId,
        stripeSubscriptionId: mockStripeSubscriptionId,
        subscriptionPlan: planId,
        subscriptionStatus: "active",
        subscriptionStartDate: /* @__PURE__ */ new Date(),
        subscriptionEndDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1e3)
        // 30 days from now
      });
      const mockCheckoutUrl = `${successUrl}?session_id=mock_session_${Date.now()}`;
      res.json({
        checkoutUrl: mockCheckoutUrl,
        sessionId: `mock_session_${Date.now()}`
      });
    } catch (error) {
      console.error("Error creating subscription:", error);
      res.status(500).json({ message: "Failed to create subscription" });
    }
  });
  app2.post("/api/subscription/cancel", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      await storage.updateUserSubscription(userId, {
        subscriptionStatus: "canceled",
        subscriptionPlan: "free",
        subscriptionEndDate: /* @__PURE__ */ new Date()
      });
      res.json({ success: true, message: "Subscription canceled successfully" });
    } catch (error) {
      console.error("Error canceling subscription:", error);
      res.status(500).json({ message: "Failed to cancel subscription" });
    }
  });
  app2.get("/api/projects", async (req, res) => {
    try {
      const projects2 = await storage.getProjects();
      res.json(projects2);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch projects" });
    }
  });
  app2.get("/api/projects/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const project = await storage.getProject(id);
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      res.json(project);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch project" });
    }
  });
  app2.post("/api/predictions", async (req, res) => {
    try {
      const validatedData = insertPredictionSchema.parse(req.body);
      const prediction = await storage.createPrediction(validatedData);
      res.json(prediction);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid input data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create prediction" });
    }
  });
  app2.get("/api/predictions", async (req, res) => {
    try {
      const predictions2 = await storage.getPredictions();
      res.json(predictions2);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch predictions" });
    }
  });
  app2.get("/api/esg-metrics", async (req, res) => {
    try {
      const metrics = await storage.getEsgMetrics();
      res.json(metrics);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch ESG metrics" });
    }
  });
  app2.get("/api/esg-metrics/project/:projectId", async (req, res) => {
    try {
      const projectId = parseInt(req.params.projectId);
      const metrics = await storage.getEsgMetricsByProjectId(projectId);
      if (!metrics) {
        return res.status(404).json({ message: "ESG metrics not found" });
      }
      res.json(metrics);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch ESG metrics" });
    }
  });
  app2.get("/api/market-insights", async (req, res) => {
    try {
      const insights = await storage.getMarketInsights();
      res.json(insights);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch market insights" });
    }
  });
  app2.post("/api/contact", async (req, res) => {
    try {
      const { name, email, company, inquiryType, subject, message, investmentRange, preferredContact } = req.body;
      console.log("Contact form submission:", {
        name,
        email,
        company,
        inquiryType,
        subject,
        message,
        investmentRange,
        preferredContact,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
      res.json({
        success: true,
        message: "Thank you for your inquiry. We'll get back to you within 24 hours."
      });
    } catch (error) {
      console.error("Contact form error:", error);
      res.status(500).json({
        success: false,
        message: "Sorry, there was an error sending your message. Please try again."
      });
    }
  });
  app2.get("/api/project-type-esg-templates", async (req, res) => {
    try {
      const templates = await storage.getProjectTypeEsgTemplates();
      res.json(templates);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch project type ESG templates" });
    }
  });
  app2.get("/api/project-type-esg-templates/:projectType", async (req, res) => {
    try {
      const { projectType } = req.params;
      const template = await storage.getProjectTypeEsgTemplate(projectType);
      if (!template) {
        return res.status(404).json({ message: "ESG template not found for project type" });
      }
      res.json(template);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch project type ESG template" });
    }
  });
  app2.get("/api/dashboard/metrics", async (req, res) => {
    try {
      const projects2 = await storage.getProjects();
      const esgMetrics2 = await storage.getEsgMetrics();
      const totalValue = projects2.reduce((sum, p) => sum + p.capacity * 1e6, 0);
      const avgIrr = projects2.reduce((sum, p) => sum + p.irr, 0) / projects2.length;
      const avgEsg = esgMetrics2.reduce((sum, e) => sum + e.overall, 0) / esgMetrics2.length;
      const lowRiskProjects = projects2.filter((p) => p.riskLevel === "low").length;
      const riskLevel = lowRiskProjects / projects2.length > 0.7 ? "Low" : "Medium";
      res.json({
        averageIRR: Math.round(avgIrr * 10) / 10,
        esgScore: Math.round(avgEsg * 10) / 10,
        analyzedValue: `\u20A6${Math.round(totalValue / 1e6)}M+`,
        riskLevel
      });
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch dashboard metrics" });
    }
  });
  app2.get("/api/rewards/stats", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const stats = await storage.getUserRewardStats(userId);
      res.json(stats);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch reward stats" });
    }
  });
  app2.get("/api/rewards/achievements", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const achievements2 = await storage.getUserAchievements(userId);
      res.json(achievements2);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch achievements" });
    }
  });
  app2.get("/api/rewards/activities", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const activities = await storage.getUserRewardActivities(userId);
      res.json(activities);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch reward activities" });
    }
  });
  app2.get("/api/rewards/challenges", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const [challenges, progress] = await Promise.all([
        storage.getActiveChallenges(),
        storage.getUserChallengeProgress(userId)
      ]);
      const challengesWithProgress = challenges.map((challenge) => {
        const userProgress = progress.find((p) => p.challengeId === challenge.id);
        return {
          ...challenge,
          userProgress: userProgress || {
            progress: 0,
            completed: false,
            rewardClaimed: false
          }
        };
      });
      res.json(challengesWithProgress);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch challenges" });
    }
  });
  app2.post("/api/rewards/activity", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const { activityType, description, points, xpGained, metadata } = req.body;
      const activity = await storage.addRewardActivity({
        userId,
        activityType,
        description,
        points,
        xpGained,
        metadata
      });
      const currentStats = await storage.getUserRewardStats(userId);
      const newPoints = currentStats.sustainabilityPoints + points;
      const newXp = currentStats.xp + xpGained;
      const newLevel = Math.floor(newXp / 1e3) + 1;
      await storage.updateUserRewardStats(userId, {
        sustainabilityPoints: newPoints,
        xp: newXp,
        level: newLevel
      });
      const newAchievements = await storage.checkAndUnlockAchievements(userId);
      res.json({
        activity,
        newAchievements,
        updatedStats: {
          sustainabilityPoints: newPoints,
          xp: newXp,
          level: newLevel
        }
      });
    } catch (error) {
      res.status(500).json({ message: "Failed to add reward activity" });
    }
  });
  app2.post("/api/rewards/claim-challenge", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const { challengeId } = req.body;
      const progress = await storage.updateChallengeProgress(userId, challengeId, 1);
      res.json({
        success: true,
        progress
      });
    } catch (error) {
      res.status(500).json({ message: "Failed to claim challenge reward" });
    }
  });
  const httpServer = createServer(app2);
  return httpServer;
}

// server/vite.ts
import express from "express";
import fs from "fs";
import path2 from "path";
import { createServer as createViteServer, createLogger } from "vite";

// vite.config.ts
import { defineConfig } from "vite";
***REMOVED***act from "@vitejs/plugin-react";
import path from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";
var vite_config_default = defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    ...process.env.NODE_ENV !== "production" && process.env.REPL_ID !== void 0 ? [
      await import("@replit/vite-plugin-cartographer").then(
        (m) => m.cartographer()
      )
    ] : []
  ],
  resolve: {
    alias: {
      "@": path.resolve(import.meta.dirname, "client", "src"),
      "@shared": path.resolve(import.meta.dirname, "shared"),
      "@assets": path.resolve(import.meta.dirname, "attached_assets")
    }
  },
  root: path.resolve(import.meta.dirname, "client"),
  build: {
    outDir: path.resolve(import.meta.dirname, "dist/public"),
    emptyOutDir: true
  },
  server: {
    fs: {
      strict: true,
      deny: ["**/.*"]
    }
  }
});

// server/vite.ts
import { nanoid } from "nanoid";
var viteLogger = createLogger();
function log(message, source = "express") {
  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}
async function setupVite(app2, server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true
  };
  const vite = await createViteServer({
    ...vite_config_default,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      }
    },
    server: serverOptions,
    appType: "custom"
  });
  app2.use(vite.middlewares);
  app2.use("*", async (req, res, next) => {
    const url = req.originalUrl;
    try {
      const clientTemplate = path2.resolve(
        import.meta.dirname,
        "..",
        "client",
        "index.html"
      );
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e);
      next(e);
    }
  });
}
function serveStatic(app2) {
  const distPath = path2.resolve(import.meta.dirname, "public");
  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  app2.use(express.static(distPath));
  app2.use("*", (_req, res) => {
    res.sendFile(path2.resolve(distPath, "index.html"));
  });
}

// server/index.ts
var app = express2();
app.use(express2.json());
app.use(express2.urlencoded({ extended: false }));
app.use((req, res, next) => {
  const start = Date.now();
  const path3 = req.path;
  let capturedJsonResponse = void 0;
  const originalResJson = res.json;
  res.json = function(bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };
  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path3.startsWith("/api")) {
      let logLine = `${req.method} ${path3} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }
      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "\u2026";
      }
      log(logLine);
    }
  });
  next();
});
(async () => {
  const server = await registerRoutes(app);
  app.use((err, _req, res, _next) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";
    res.status(status).json({ message });
    throw err;
  });
  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }
  const port = process.env.PORT || 5e3;
  server.listen({
    port: Number(port),
    host: "0.0.0.0",
    reusePort: true
  }, () => {
    log(`serving on port ${port}`);
  });
})();